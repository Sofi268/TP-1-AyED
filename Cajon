#include <iostream>
#include <vector>
#include <stack>

using namespace std;



class Nodo{
    private:
        Fruta fruta;
        Nodo* next;
    public:
        Nodo(){next= NULL;};
        Nodo(Fruta m){fruta = m; next = NULL;};
        void setFruta(Fruta a){fruta = a; };
        void set_next(Nodo* n) { next = n; };
        Fruta get_fruta() { return fruta; };
        Nodo* get_next() { return next; };
        bool es_vacio() { return next == NULL; }

};

class Cajon<Fruta>{
    private:
        Nodo<Fruta>* czo;
        int ID;
        int CANT_FRUTA;
        string TIPO_FRUTA;
        bool LLENO;
    public:
        Cajon(){
            czo = new Nodo<Fruta>();  
            ID = 0;
            CANT_FRUTA = 0;
            TIPO_FRUTA = "";
            LLENO = false;
         }
         Cajon(Nodo<Fruta>* n) { czo = n; };
         //Setters
         void setTipoFruta(string s);
         void setCantFrutaCajon();
         void setCajonLleno();
         void setCajonVacio();
         void setID(int i);
         //Getters
         string getTipoFruta();
         int getID();
         int getCantidadFrutaCajon();
         bool getEstadoCajon();

         //Funciones       
         void agregarNodo(Fruta f);
         void eliminarNodo(void);
         int llenarCajon(Fruta f);
         int vaciarCajon(Fruta f);
         int agregarFrutas(Fruta f, int CANTIDAD_ACTUAL);
         bool comprobarEspacioLibre(Fruta f, int CANTIDAD_ACTUAL);  
         bool esvacia(void);
         Cajon* restoCajon(void);
         int frutaAgregada(int a, int b);
         int cajonDisponible(Cajon cajones[]);
};

void Cajon<Fruta>::setTipoFruta(string s){
    TIPO_FRUTA = s;    
}

void Cajon<Fruta>::setCajonLleno(){
    LLENO = true;
}
void Cajon<Fruta>::setCajonVacio(){
    LLENO = false;
}

void Cajon<Fruta>::setID(int i){
    ID = i;
}

void Cajon<Fruta>::setCantFrutaCajon(){
    if (this->esvacia()) {CANT_FRUTA =  0;}
    else{
    CANT_FRUTA = 1 + this->restoCajon()->setCantFrutaCajon();
    }
}

string Cajon<Fruta>::getTipoFruta(){
    return TIPO_FRUTA;
}

int Cajon<Fruta>::getID(){
    return ID;
}

int Cajon<Fruta>::getCantidadFrutaCajon(){
    return CANT_FRUTA;
}

bool Cajon<Fruta>::getEstadoCajon(){
    return LLENO;
}

void Cajon<Fruta>::agregarNodo(Fruta f){
        Nodo<Fruta>* nueva = new Nodo<Fruta>(f);
        nueva->setnext(czo);
        czo = nueva;
}

void Cajon<Fruta>::eliminarNodo(void)
{ 
    if (!this->esvacia()) {
        Nodo<Fruta>* aux = czo;
        czo = czo->get_next();
        delete aux;
    }
}

bool Cajon<Fruta> ::esvacia(void)
{
    return czo->es_vacio();
}

int Cajon<Fruta>::llenarCajon(Fruta f){
    int a,g = f.getCantFruta();
    int a1=getCantidadFrutaCajon();
    while(a1<20&&g>0){
        agregarNodo();
        g--;
        a1++;
    }
    if(a1==20){setCajonLleno();}
    return g;
}
int Cajon<Fruta>::frutaAgregada(int a, int b){
    int c;
    c= b-a;
    return c;
}
int Cajon<Fruta>::vaciarCajon(Fruta f){
    int g = f.getCantFruta();
    int a1 = getCantidadFrutaCajon();
    while(a1>0&&g>0){
        eliminarNodo();
        g--;
        a1--;
    }
    if(a1==0){setCajonVacio();}
    return g;
}
Cajon<Fruta>* Cajon<Fruta>::restoCajon(void)
{
    Cajon* c = new Cajon(czo->get_next());
    return (c);
}
int Cajon<Fruta>::agregarFrutas(Fruta f, int CANTIDAD_ACTUAL){
    int r=0;
    if(comprobarEspacioLibre(f, CANTIDAD_ACTUAL)){
         r = llenarCajon();
    }
    else {
        cout<<"No hay espacio disponible en los cajones para guardar "<<f.getCantFruta()<<endl;
    }
    return r;
}

bool Cajon<Fruta>::comprobarEspacioLibre(Fruta f,int CANTIDAD_ACTUAL){
    if((CANTIDAD_ACTUAL+f.getCantFruta())<200)return true;
    else return false;
}

int Cajon<Fruta>::cajonDisponible(Cajon cajones[]){
    int y = 0;
    bool disp = false;
    for(int i=0; i<10; i++){
        if(cajones[i].getEstadoCajon()){
            y=i;
            disp = true;
            break;
        }
    }
    if(disp)return y;
    else {
        cout<<"No hay cajones disponibles"<<endl; 
        return 0;
    }
}
