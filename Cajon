#include <iostream>
#include <vector>
#include <stack>

using namespace std;

template<class Fruta> class Nodo{
    private:
        Fruta fruta;
        Nodo* next;
    public:
        Nodo(){next= NULL;};
        Nodo(Fruta m){fruta = m; next = NULL;};
        void setFruta(Fruta a){fruta = a; };
        void setnext(Nodo* n) {next = n;};
};

class Cajon: public Fruta{
    private:
        Nodo<Fruta>* czo;
        int ID;
        int CANT_FRUTA;
        string TIPO_FRUTA;
        bool LLENO;
    public:
        Cajon(){
            czo = new Nodo<Fruta>();  
            ID = 0;
            CANT_FRUTA = 0;
            TIPO_FRUTA = "";
            LLENO = false;
         }
         //Setters
         void setTipoFruta(string s);
         void setCajonLleno();
         void setID(int i);
         //Getters
         string getTipoFruta();
         int getID();
         int getCantidadFrutaCajon();
         bool getEstadoCajon();

         //Funciones       
         void agregarNodo();
         void eliminarNodo();
         void llenarCajon(Fruta f);
         void vaciarCajon(Fruta f);
         void agregarFrutas(Fruta f, int CANTIDAD_ACTUAL);
         bool comprobarEspacioLibre(Fruta f, int CANTIDAD_ACTUAL);  
         int divCajones(Fruta f);
};

void Cajon::setTipoFruta(string s){
    TIPO_FRUTA = s;    
}

void Cajon::setCajonLleno(){
    LLENO = true;
}

void Cajon::setID(int i){
    ID = i;
}

string Cajon::getTipoFruta(){
    return TIPO_FRUTA;
}

int Cajon::getID(){
    return ID;
}

int Cajon::getCantidadFrutaCajon(){
    return CANT_FRUTA;
}

bool Cajon::getEstadoCajon(){
    return LLENO;
}

void Cajon::agregarNodo(){
        Nodo<Fruta>* nueva = new Nodo<Fruta>(f);
        nueva->setnext(czo);
        czo = nueva;
        CANT_FRUTA++;
}
void Cajon::eliminarNodo(){

}
void Cajon::llenarCajon(Fruta f){
    int resto = 0;
    int frutaAgregar = ((20- CANT_FRUTA) / f.getCantFruta());
    for(int i= 0; i<frutaAgregar; i++){
        agregarNodo();
        CANT_FRUTA++;
    }
    setTipoFruta(f.getFruta());
    if (CANT_FRUTA ==20){setCajonLleno();}
    resto = f.getCantFruta() - frutaAgregar;
}
void Cajon::vaciarCajon(){
    
}
void Cajon::agregarFrutas(Fruta f, int CANTIDAD_ACTUAL){
    if(comprobarEspacioLibre(f, CANTIDAD_ACTUAL)){
        int cajones= divCajones(f);
        for(int i=0; i>cajones ; i++){
            llenarCajon(f);
        }
    }
    else {
        cout<<"No hay espacio disponible en los cajones para guardar "<<f.getCantFruta()<<endl;
    }
}

bool Cajon::comprobarEspacioLibre(Fruta f,int CANTIDAD_ACTUAL){
    if((CANTIDAD_ACTUAL+f.getCantFruta())<200){
        agregarFrutas(f);
    }
    else{

    }
}
int Cajon::divCajones(Fruta f){
    int cajones, residual =0;
    int n;
    int n = f.getCantFruta();
    while(n>20){
        n=n-20;
        cajones++;
    }     
    residual=n;
    return cajones;
}

