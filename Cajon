#include <iostream>
#include <vector>
#include <stack>

using namespace std;
#include 
class Cajon{
    private:
        int ID;
        int CANT_FRUTA;
        string TIPO_FRUTA;
        bool LLENO;

    //CONSTRUCTOR
        ID = 0;
        CANT_FRUTA = 0;
        TIPO_FRUTA = "";
        LLENO = false;
    }

    //GETTERS
    int getID(){return ID;}
    int getCantFruta(){return CANT_FRUTA;}
    string getTipoFruta(){return TIPO_FRUTA;}
    bool getLleno(){return LLENO;}

template<class Fruta> class Nodo{
    private:
        Fruta fruta;
        Nodo* siguiente;
    public:
        Nodo(){siguiente= NULL;};
        Nodo(Fruta m){fruta = m; sigueinte = NULL;};
        void setFruta(Fruta a){fruta = a; };
        void setSiguiente(Nodo* n) {siguiente = n;};
        Fruta getNombreFruta(){return fruta.getFruta;};
        Fruta getCantidadFruta(){return fruta.getCantFruta;};
        Nodo* getSiguiente(){return siguiente;};
        bool vacio(){return siguiente == NULL;}
};

template<class Fruta> class Cajon{
    private:
        Nodo<Fruta>* czo;
        int ID;
        int CANT_FRUTA;
        string TIPO_FRUTA;
        bool LLENO;
    public:
        Cajon(){
            czo = new Nodo<Fruta>();  
            ID = 0;
            CANT_FRUTA = 0;
            TIPO_FRUTA = "";
            LLENO = false;
         };
        Cajon(Nodo<Fruta>* n){ czo = n;};
        void agregar(Fruta t);
        //Setters
        void setTipoFrutaCajon(Fruta f){ TIPO_FRUTA = f.getTipoFruta();}
        void setCantidadFrutaCajon(Fruta f){ CANT_FRUTA = f.getCantFruta();}
        void setID(){};
};      

void Cajon::agregar(Fruta t){
    Nodo<Fruta>* nueva = new Nodo<Fruta>(t);
    nueva->setSiguiente(czo);
    czo = nueva;        
}
bool Cajon::cajonVacio(){
    return czo -> vacio();
}

void Cajon::divCajones(){
    int cajones,n,residual; n=getCantFruta();
    if(n>20){
        n=n-20;
        cajones++;
        divCajones();
    }     
    else if (n==20){
        n=n-20;
        cajones++;      
    }
    else {
        residual=n;
    }
        cout<<"Cajones Necesarios: "<<cajones<<" + residual"<<n;

    }
void Cajon::disminuirFruta_Cajon(){
    int aux,cajones;
    cout<<"Cuantos cajones se vendieron? "; cin>>cajones;
    aux=CANT_FRUTA-20*cajones;
    if(aux==0){CANT_FRUTA=aux; cout<<"\nEXISTENCIAS VACIAS, REPONER"<<endl;}
    else if(aux<0)cout<<"\nENTREGA PENDIENTE, REPONER"<<endl;
    else CANT_FRUTA=aux;
    }

void Cajon::aumentarFruta(){
    int cant, aux; 
    cout<<"Cuantos kg se compraron?: ";cin>>cant;
    aux=CANT_FRUTA+cant;
    if(aux<=200) CANT_FRUTA=aux;
    else{
        cout<<"El total almacenable no puede ser superior a 200KG"<<endl;
        aumentarFruta();
    }

    }

void Cajon::disminuirFruta(){
    int aux,kgFruta;
    cout<<"Cuantos kg de fruta se vendieron? "; cin>>kgFruta;
    aux=CANT_FRUTA-kgFruta;
    if(aux==0){CANT_FRUTA=aux; cout<<"\nEXISTENCIAS VACIAS, REPONER"<<endl;}
    else if(aux<0)cout<<"\nENTREGA PENDIENTE, REPONER"<<endl;
    else CANT_FRUTA=aux;
}

void Cajon::setID(){
    
}
