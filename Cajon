#include <iostream>
#include <vector>
#include <stack>

using namespace std;


template<class Fruta> class Nodo{
    private:
        Fruta fruta;
        Nodo* next;
    public:
        Nodo(){next= NULL;};
        Nodo(Fruta m){fruta = m; next = NULL;};
        void setFruta(Fruta a){fruta = a; };
        void set_next(Nodo* n) { next = n; };
        Fruta get_fruta() { return fruta; };
        Nodo* get_next() { return next; };
        bool es_vacio() { return next == NULL; }

};

template <class Fruta> class Cajon: public Fruta{
    private:
        Nodo<Fruta>* czo;
        int ID;
        int CANT_FRUTA;
        string TIPO_FRUTA;
        bool LLENO;
    public:
        Cajon(){
            czo = new Nodo<Fruta>();  
            ID = 0;
            CANT_FRUTA = 0;
            TIPO_FRUTA = "";
            LLENO = false;
         }
         Cajon(Nodo<Fruta>* n) { czo = n; };
         //Setters
         void setTipoFruta(string s);
         void setCantFrutaCajon();
         void setCajonLleno();
         void setCajonVacio();
         void setID(int i);
         //Getters
         string getTipoFruta();
         int getID();
         int getCantidadFrutaCajon();
         bool getEstadoCajon();

         //Funciones       
         void agregarNodo(Fruta f);
         void eliminarNodo(void);
         int llenarCajon(Fruta f);
         int vaciarCajon(Fruta f);
         void agregarFrutas(Fruta f, int CANTIDAD_ACTUAL);
         bool comprobarEspacioLibre(Fruta f, int CANTIDAD_ACTUAL);  
         bool esvacia(void);
         Cajon* restoCajon(void);
};

template <class Fruta> void Cajon<Fruta>::setTipoFruta(string s){
    TIPO_FRUTA = s;    
}

template <class Fruta> void Cajon<Fruta>::setCajonLleno(){
    LLENO = true;
}
template <class Fruta> void Cajon<Fruta>::setCajonVacio(){
    LLENO = false;
}

template <class Fruta> void Cajon<Fruta>::setID(int i){
    ID = i;
}

template <class Fruta> void Cajon<Fruta>::setCantFrutaCajon(){
    if (this->esvacia()) {CANT_FRUTA =  0;}
    else{
    CANT_FRUTA = 1 + this->restoCajon()->setCantFrutaCajon();
    }
}

template <class Fruta> string Cajon<Fruta>::getTipoFruta(){
    return TIPO_FRUTA;
}

template <class Fruta> int Cajon<Fruta>::getID(){
    return ID;
}

template <class Fruta> int Cajon<Fruta>::getCantidadFrutaCajon(){
    return CANT_FRUTA;
}

template <class Fruta> bool Cajon<Fruta>::getEstadoCajon(){
    return LLENO;
}

template <class Fruta> void Cajon<Fruta>::agregarNodo(Fruta f){
        Nodo<Fruta>* nueva = new Nodo<Fruta>(f);
        nueva->setnext(czo);
        czo = nueva;
}

template <class Fruta> void Cajon<Fruta>::eliminarNodo(void)
{ 
    if (!this->esvacia()) {
        Nodo<Fruta>* aux = czo;
        czo = czo->get_next();
        delete aux;
    }
}
template <class Fruta> bool Cajon<Fruta> ::esvacia(void)
{
    return czo->es_vacio();
}
template <class Fruta> int Cajon<Fruta>::llenarCajon(Fruta f){
    int g = f.getCantFruta();
    int a1=getCantidadFrutaCajon();
    while(a1<20&&g>0){
        agregarNodo();
        g--;
        a1++;
    }
    if(a1==20){setCajonLleno();}
    return g;
}
template <class Fruta> int Cajon<Fruta>::vaciarCajon(Fruta f){
    int g = f.getCantFruta();
    int a1=getCantidadFrutaCajon();
    while(a1>0&&g>0){
        eliminarNodo();
        g--;
        a1--;
    }
    if(a1==0){setCajonVacio();}
    return g;
}
template <class Fruta> Cajon<Fruta>* Cajon<Fruta>::restoCajon(void)
{
    Cajon* c = new Cajon(czo->get_next());
    return (c);
}
template <class Fruta> void Cajon<Fruta>::agregarFrutas(Fruta f, int CANTIDAD_ACTUAL){
    if(comprobarEspacioLibre(f, CANTIDAD_ACTUAL)){
        llenarCajon();
    }
    else {
        cout<<"No hay espacio disponible en los cajones para guardar "<<f.getCantFruta()<<endl;
    }
}

template <class Fruta> bool Cajon<Fruta>::comprobarEspacioLibre(Fruta f,int CANTIDAD_ACTUAL){
    if((CANTIDAD_ACTUAL+f.getCantFruta())<200)return true;
    else return false;
}
